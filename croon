#!/usr/bin/env perl

#*!
# * croon 0.1.0
# * https://github.com/aadel112/croon/croon
# * @license GNU v3
# *
# * Copyright (C) 2016 - aadel112.com - A project by Aaron Adel    
# */

use Schedule::Cron;
use Getopt::Std;
use File::Basename;
use Data::Dumper;

main();

sub main{
    get_opts();
    %CFG = read_cfg() if( -s $CONFIG );

    my $cron = new Schedule::Cron(\&dispatcher);
    $cron->load_crontab( $CRONFILE ) or die "Couldn't load your cronfile - $CRONFILE";
    $cron->run(detach=>$FG?0:1, catch=>1);
#     $cron->run();

    return 0;
}

sub dispatcher {
    my $cmd = shift;

    my $new_cmd = get_croon_cmd( $cmd );
#     print "$new_cmd\n";
    fork_cmd( $new_cmd );
}

sub fork_cmd {
    my $cmd = shift;
    my $pid = fork();
    
    return undef if($pid); #parent
    return fkd_exec($cmd) if($pid==0); #child
    return -1; #error
}

sub fkd_exec {
    my $cmd = shift;
    my $rc = system( $cmd );
}

sub get_croon_cmd {
    my $cmd = shift;

    my $time = which('time');
    my $ionice = which('ionice');

    my @actions = get_actions( $cmd );

    foreach my $act ( @actions ) {
   
        my $nice = get_nicestr($act);

        $cmd =~ s/$act/$time $nice $ionicestr $act/;
    }
    return $cmd;
}

sub get_actions {
    my $cmd = shift;

    my @actions = $cmd =~ /(?ips)[^\s\;><|]+/g;
    my $sz = scalar @actions;
    for( my $i = $sz - 1; $i >= 0; --$i ) {
        my $ac = $actions[$i];
        pop @actions if( !-X $ac && !-X which($ac) );
    }
    return @actions;
}

sub get_nicestr {
    my $proc = basename( $_[0] );

    my $prio = $CFG{$proc}->{'nice'};
    $prio = defined $prio ? $prio : $DNICE;
    return undef unless( $prio );

    return nice( $prio );
}

sub get_ionicestr {
    my $proc = basename( $_[0] );

    my $prio = $CFG{$proc}->{'ionice'};
    $prio = defined $prio ? $prio : $DIO;
    return undef unless( $prio );

    return ionice( $prio );
}

sub get_timestr {
    my $proc = basename( $_[0] );
    my $time = which('time');

    return $time;
}

sub nice {
    my ( $prio ) = @_;
    my $nice = which('nice');
    return undef unless( $nice );

    return "$nice -n$prio";
}

sub ionice {
	my ( $prio ) = @_;
    my $ionice = which('ionice');
    return undef unless( $ionice );

    return "$ionice -n$prio";
}

sub which { 
    return undef if( $_[0] =~ /&/ );
    my $cmd = "which $_[0] 2>/dev/null";
    my $which = `$cmd`;
    chomp $which; 
    return $which; 
}

sub read_config {
    my %ret = ();
	# processname, niceness, ioniceness, profile
    if( -s $CONFIG ) {
        open my $fh, '<', $CONFIG or die "Cannot open $CONFIG: $!";
        while ( my $line = <$fh> ) {
            chomp;
            my ( $proc, $nice, $ionice, $prof ) = split /,/, $line;
            my %tmp = (
                'nice' => $nice,
                'ionice' => $ionice,
                'prof' => $prof
            );
            $proc = basename( $proc );
            $ret{$proc} = \%tmp;
        }
        close $fh;
    }
    return %ret;
}

sub get_opts {
	my %o = ();
    getopts('C:F:N:D:PZ',\%o);

    $CRONFILE = $o{F} ? $o{F} : undef;
    $CONFIG = $o{C} ? $o{C} : undef;
    $DNICE = $o{N} ? $o{N} : 10;
    $DIO = $o{D} ? $o{D} : 4;
    $SKIP_PROFILE = defined $o{P} ? 1 : 0;
    $FG = defined $o{Z} ? 1 : 0;
}
